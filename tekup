#!/usr/bin/env bash

declare verbose=0
declare processes=1
declare expire_length
declare request_deletion_key
declare log_file
declare -r c_red=$(tput setaf 1)
declare -r c_blue=$(tput setaf 4)
declare -r c_reset=$(tput sgr0)

info() {
  printf "${c_blue}%s${c_reset}\n" "$1" >&2
}
export -f info

err() {
  printf "${c_red}%s${c_reset}\n" "$1" >&2
}
export -f err

die() {
  [[ -n "$1" ]] && err "$1"
  exit 1
}
export -f err

usage() {
  LESS=-FEXR less <<-'HELP'
Usage: tekup [OPTIONS] FILES..
Upload files to https://teknik.io

OPTIONS:
  -h           print this help
  -v           print verbose output. can be stacked. there are two levels of
               verbosity (because this thing is over-engineered), the first
               will print the JSON response from teknik, the second will also
               pass the -v option to curl
  -d           request a deletion key for images
  -e <STRING>  expiration time. only has an effect on text pastes.
               must be in the form of 'N UNITS' where N is a number
               and UNIT is one of the following:
               minute hour day month year
HELP
}

has() {
  local verbose
  if [[ $1 = '-v' ]]; then
    verbose=1
    shift
  fi
  for c; do c="${c%% *}"
    if ! command -v "$c" &> /dev/null; then
      (( "$verbose" > 0 )) && err "$c not found"
      return 1
    fi
  done
}

upload_text() {
  local file curl_opts
  file="$1"
  shift
  curl_opts=()
  case "$verbose" in
    0) curl_opts+=( -s ) ;;
    2) curl_opts+=( -v ) ;;
  esac

  if [[ -n "$expire_length" ]]; then
    printf -v expire_length '%d' "${expire_length% *}"
    expire_unit="${expire_length#* }"
    curl_opts+=( --data "expireLength=${expire_length}&expireUnit=${expire_unit/%s}" )
  fi
  curl_opts+=( --data "doNotTrack=true&title=${file##*/}" --data-urlencode "code=$(< "$file")" https://api.teknik.io/v1/Paste)
  curl "${curl_opts[@]}" | parse_response
}

upload_file() {
  local file mime curl_opts
  file="$1"
  mime="$2"
  shift 2
  curl_opts=()
  case "$verbose" in
    0) curl_opts+=( -s ) ;;
    2) curl_opts+=( -v ) ;;
  esac

  [[ -n "$request_deletion_key" ]] &&
    curl_opts+=( -F 'genDeletionKey=true' )
  curl_opts+=(   -F 'doNotTrack=true'
                 -F "contentType=${mime%%;*}"
                 -F "file=@${file}"
                 https://api.teknik.io/v1/Upload )
  curl "${curl_opts[@]}" | parse_response
}

upload_files() {
  local curl_opts f mime

  for f; do
    if [[ ! -e "$f" ]]; then
      err "$f does not exist"
      continue
    fi

    mime=$(file -Lib "$f")
    if [[ "${mime%%/*}" = 'text' ]]; then
      upload_text "$f"
    else
      upload_file "$f" "$mime"
    fi
  done
}

parse_response() {
  local url deletion_key expire_date
  read -r response

  (( verbose > 0 )) && jq <<< "$response"

  if [[ "$response" != *'http'* || -z "$response" || "$response" = *'error'* ]]; then
    err "error uploading $file"
    if (( verbose < 1 )); then
      if [[ "$response" = *'error'* ]]; then
        err "$(jq -r '.error.message' <<< "$response")"
      elif [[ -n "$response" ]]; then
        err "$response"
      fi
    fi
    die
  fi

  url=$(jq -r '.result.url' <<< "$response")

  url="${url/paste.teknik.io/p.teknik.io\/Raw}"
  url="${url/upload/u}"

  printf '%s: %s\n' "$file" "$url"
  if [[ -n "$request_deletion_key" ]]; then
    deletion_key=$(jq -r '.result.deletion_key' <<< "$response")
    # [[ "$deletion_key" != null ]] &&
      printf 'deletion_key: %s/%s\n' "$url" "$deletion_key"
  elif [[ -n "$expire_date" ]]; then
    expire_date=$(jq -r '.result.expiration | match("[0-9]+").string' <<< "$response")
    # [[ "$expire_date" = null ]] &&
      printf 'expires at: %s\n' "$(date -d "@$expire_date")"
  fi
}

has -v curl jq || die

OPTERR=0
while getopts 'hve:d' opt; do
  case "$opt" in
    h) usage; exit 0 ;;
    v) (( ++verbose )) ;;
    e) expire_length="$OPTARG" ;;
    d) request_deletion_key=1 ;;
  esac
done
shift $(( OPTIND - 1 ))
unset OPTIND

(( $# > 0 )) || die 'No files to upload.'

upload_files "$@"
