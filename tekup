#!/usr/bin/env bash

declare verbose=0
declare processes=1
declare expire
declare delete_key
declare log_file
declare -r config_file="${XDG_CONFIG_DIR:-$HOME/.config}/fzmp/conf"
declare -r c_red=$(tput setaf 1)
declare -r c_blue=$(tput setaf 4)
declare -r c_reset=$(tput sgr0)

info() {
  printf "${c_blue}%s${c_reset}\n" "$1" >&2
}
export -f info

err() {
  printf "${c_red}%s${c_reset}\n" "$1" >&2
}
export -f err

die() {
  [[ -n "$1" ]] && err "$1"
  exit 1
}
export -f err

usage() {
  LESS=-FEXR less <<-'HELP'
Usage: tekup [OPTIONS] FILES..
Upload files to https://teknik.io

OPTIONS:
  -h           print this help
  -v           print verbose output. there are two levels of verbosity
               (because this thing is over-engineered), the first will print
               the JSON response from teknik, the second will also pass the
               -v option to curl
  -e <STRING>  expiration time. only has an effect on text pastes.
               must be in the form of 'N UNITS' where N is a number
               and UNIT is one of the following:
               minute hour day month year
  -d           request a deletion key for images
HELP
}

has() {
  local verbose
  if [[ $1 = '-v' ]]; then
    verbose=1
    shift
  fi
  for c; do c="${c%% *}"
    if ! command -v "$c" &> /dev/null; then
      (( "$verbose" > 0 )) && err "$c not found"
      return 1
    fi
  done
}

parse_config_file() {
  local line key val nr=0
  while IFS= read -r line; do
    (( ++nr ))
    [[ -z "$line" || "$line" = '#'* ]] && continue
    read -r key <<< "${line%% *}"
    read -r val <<< "${line#* }"
    if [[ -z "$val" ]]; then
      config_err+=( "missing value for \"$key\" in config file on line $nr" )
      continue
    fi
    case "$key" in
      log_file) log_file="$val" ;;
      generate_deletion_key) log_file="$val" ;;
      # full_song_format) track_format="$val" ;;
      # fzf_options) [[ ! -v FZMP_FZF_OPTIONS ]] && FZMP_FZF_OPTIONS="$val" ;;
      # default_view)
      #   if [[ "$val" =~ playlist|songs|artists ]]; then
      #     case "$val" in
      #       playlist) default_filter='filter_by_playlist' ;;
      #       songs) default_filter='filter_all_songs' ;;
      #       artists) default_filter='filter_by_artist' ;;
      #     esac
      #   else
      #     config_err+=( "unknown vi \"$val\" in config file on line $nr" )
      #   fi
      #   ;;
      *) config_err+=( "unknown key \"$key\" in config file on line $nr" )
    esac
  done
}

upload_text() {
  local file curl_opts
  file="$1"
  shift
  curl_opts=()
  case "$verbose" in
    0) curl_opts+=( -s ) ;;
    2) curl_opts+=( -v ) ;;
  esac

  if [[ -n "$expire" ]]; then
    printf -v expire_length '%d' "${expire% *}"
    expire_unit="${expire#* }"
    curl_opts+=( --data "expireLength=${expire_length}&expireUnit=${expire_unit/%s}" )
  fi
  curl_opts+=( --data "doNotTrack=true&title=${file##*/}" --data-urlencode "code=$(< "$file")" https://api.teknik.io/v1/Paste)
  curl "${curl_opts[@]}" | parse_response
}

upload_file() {
  local file mime curl_opts
  file="$1"
  mime="$2"
  shift 2
  curl_opts=()
  case "$verbose" in
    0) curl_opts+=( -s ) ;;
    2) curl_opts+=( -v ) ;;
  esac

  [[ -n "$delete_key" ]] &&
    curl_opts+=( -F 'genDeletionKey=true' )
  curl_opts+=(   -F 'doNotTrack=true'
                 -F "contentType=${mime%%;*}"
                 -F "file=@${file}"
                 https://api.teknik.io/v1/Upload )
  curl "${curl_opts[@]}" | parse_response
}

upload_files() {
  local curl_opts f mime

  for f; do
    if [[ ! -e "$f" ]]; then
      err "$f does not exist"
      continue
    fi

    mime=$(file -Lib "$f")
    if [[ "${mime%%/*}" = 'text' ]]; then
      upload_text "$f"
    else
      upload_file "$f" "${mime%%/*}"
    fi

  done
}

parse_response() {
  local url deletion_key
  read -r response

  (( verbose > 0 )) && jq <<< "$response"

  if [[ "$response" != *'http'* || -z "$response" || "$response" = *'error'* ]]; then
    err "error uploading $file"
    if (( verbose < 1 )); then
      if [[ "$response" = *'error'* ]]; then
        err "$(jq -r '.error.message' <<< "$response")"
      elif [[ -n "$response" ]]; then
        err "$response"
      fi
    fi
    die
  fi

  url=$(jq -r '.result.url' <<< "$response")

  url="${url/paste.teknik.io/p.teknik.io\/Raw}"
  url="${url/upload/u}"

  printf '%s: %s\n' "$file" "$url"
  if [[ -n "$delete_key" ]]; then
    deletionKey=$(jq -r '.result.deletionKey' <<< "$response")
    # [[ "$deletionKey" != null ]] &&
      printf 'deletion_key: %s/%s\n' "$url" "$deletionKey"
  elif [[ -n "$expire" ]]; then
    expire_time=$(jq -r '.result.expiration | match("[0-9]+").string' <<< "$response")
    # [[ "$expire_time" = null ]] &&
      printf 'expires at: %s\n' "$(date -d "@$expire_time")"
  fi
}

has -v curl jq || die

[[ -s "$config_file" ]] && parse_config_file < "$config_file"

OPTERR=0
while getopts 'hve:d' opt; do
  case "$opt" in
    h) usage; exit 0 ;;
    v) (( ++verbose )) ;;
    e) expire="$OPTARG" ;;
    d) delete_key=1 ;;
  esac
done
shift $(( OPTIND - 1 ))
unset OPTIND

(( $# > 0 )) || die 'No files to upload.'

upload_files "$@"
