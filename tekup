#!/usr/bin/env bash

declare verbose=0
declare expire_length
declare request_deletion_key
declare -A colors
colors[red]=$(tput setaf 1)
colors[reset]=$(tput sgr0)

err() {
  printf "%s%s%s\n" "${colors[red]}" "${colors[reset]}" "$*" >&2
}

die() {
  [[ -n "$1" ]] && err "$1"
  exit 1
}

usage() {
  LESS=-FEXR less <<-'HELP'
Usage: tekup [OPTIONS] FILES..
Upload files to https://teknik.io

OPTIONS:
  -h           print this help
  -d           request a deletion key for images
  -e <STRING>  expiration time. only has an effect on text pastes.
               must be in the form of 'N UNIT' where N is a number
               and UNIT is one of the following:
               minute hour day month year
  -v           print verbose output. can be stacked. there are three levels of
               verbosity (because this thing is over-engineered)
               first will show progress from curl
               second will print the json response
               third will show verbose output from curl

If ~/.config/tekup/log is a writeable file tekup will always ask for a
deletion key and log it in that file.
HELP
}

has() {
  local _verbose
  if [[ $1 = '-v' ]]; then
    _verbose=1
    shift
  fi
  for c; do c="${c%% *}"
    if ! command -v "$c" &> /dev/null; then
      (( _verbose > 0 )) && err "$c not found"
      return 1
    fi
  done
}

upload_text() {
  local file curl_opts expire_unit
  file="$1"
  shift
  curl_opts=()
  case "$verbose" in
    0) curl_opts+=( -s ) ;;
    1|2) curl_opts+=( ) ;;
    *) curl_opts+=( -v ) ;;
  esac

  if [[ -n "$expire_length" ]]; then
    printf -v expire_l '%d' "${expire_length% *}"
    expire_unit="${expire_l#* }"
    curl_opts+=( --data "expireLength=${expire_l}&expireUnit=${expire_unit/%s}")
  fi
  curl_opts+=(
    --data "doNotTrack=true&title=${file##*/}"
    --data-urlencode "code=$(< "$file")"
    https://api.teknik.io/v1/Paste )
  curl "${curl_opts[@]}" | parse_response
}

upload_file() {
  local file mime curl_opts
  file="$1"
  mime="$2"
  shift 2
  curl_opts=()
  case "$verbose" in
    0) curl_opts+=( -s ) ;;
    1|2) curl_opts+=( ) ;;
    *) curl_opts+=( -v ) ;;
  esac

  [[ -w "$log_file" || -n "$request_deletion_key" ]] &&
    curl_opts+=( -F 'genDeletionKey=true' )
  curl_opts+=(   -F 'doNotTrack=true'
                 -F "contentType=${mime%%;*}"
                 -F "file=@${file}"
                 https://api.teknik.io/v1/Upload )
  curl "${curl_opts[@]}" | parse_response
}

upload_files() {
  local curl_opts f mime

  for f; do
    if [[ ! -e "$f" ]]; then
      err "$f does not exist"
      continue
    fi

    mime=$(file -Lib "$f")
    if [[ "${mime%%/*}" = 'text' ]]; then
      upload_text "$f"
    else
      upload_file "$f" "$mime"
    fi
  done
}

parse_response() {
  local url deletion_key expire_date log_msg
  read -r response

  (( verbose > 1 )) && jq <<< "$response"

  if [[ "$response" != *'http'* || -z "$response" || "$response" = *'error'* ]]; then
    err "error uploading $file"
    if (( verbose < 1 )); then
      err "$(jq -r '.error.message' <<< "$response")" || err "$response"
    fi
    die
  fi

  url=$(jq -r '.result.url' <<< "$response")

  url="${url/paste.teknik.io/p.teknik.io\/Raw}"
  url="${url/upload/u}"

  printf '%s: %s\n' "$file" "$url"

  if [[ -w "$log_file" || -n "$request_deletion_key" ]]; then
    deletion_key=$(jq -r '.result.deletionKey' <<< "$response") || jq "$response"
    [[ -n "$deletion_key" ]] && printf 'deletion key: %s/%s\n' "$url" "$deletion_key"
  fi

  if [[ -n "$expire_length" ]]; then
    expire_date=$(jq -r '.result.expiration | match("[0-9]+").string' <<< "$response") || jq "$response"
    [[ -n "$expire_date" ]] &&
      printf 'expires at: %s\n' "$(date -d "@$expire_date")"
  fi

  if [[ -w "$log_file" ]]; then
    log_msg="$(date +%s) | file: $file | url: $url"
    [[ -n "$expire_date" ]] &&
      log_msg+=" | expires: $expire_date"
    [[ -n "$deletion_key" ]] &&
      log_msg+=" | delete: $url/$deletion_key"
    echo "$log_msg" >> "$log_file"
  fi
}

has -v curl jq || die

OPTERR=0
while getopts 'hve:d' opt; do
  case "$opt" in
    h) usage; exit 0 ;;
    v) (( ++verbose )) ;;
    e) expire_length="$OPTARG" ;;
    d) request_deletion_key=1 ;;
  esac
done
shift $(( OPTIND - 1 ))
unset opt OPTARG OPTIND

(( $# > 0 )) || die 'No files to upload.'

upload_files "$@"
